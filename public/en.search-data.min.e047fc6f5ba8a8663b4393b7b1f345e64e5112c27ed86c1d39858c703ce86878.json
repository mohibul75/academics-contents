[{"id":0,"href":"/docs/details/","title":"Details","section":"Docs","content":" ğŸ“š Distributed Systems Lab â€” Detailed Breakdown # This lab is structured as a step-by-step journey through the lifecycle of building a distributed system with microservices.\nğŸš€ Phase 1: Monolithic Smart Library System # We begin with a monolithic design, where all components of the system reside in a single codebase.\nYouâ€™ll Learn:\nHow to structure a monolithic application Why monoliths become difficult to scale and maintain Building core modules: Users, Catalog, Borrowing Separation of concerns: Controller â†’ Service â†’ Repository layers ğŸ§© Phase 2: Transition to Microservices # Next, we break down the monolith into independently deployable microservices.\nYouâ€™ll Learn:\nHow to decompose services by business capability RESTful API communication between services Managing independent data sources Principles of loose coupling and bounded context ğŸŒ Phase 3: Reverse Proxy with Nginx # We introduce Nginx to centralize and manage access to microservices.\nYouâ€™ll Learn:\nHow reverse proxies work Nginx configuration for routing and load balancing Handling HTTPS and static files with Nginx Benefits of centralized access control and logging ğŸ³ Phase 4: Containerization with Docker # Now we containerize each service to ensure consistency across environments.\nYouâ€™ll Learn:\nWriting Dockerfiles for services Managing containers, images, and networks Creating isolated environments for each service âš™ï¸ Phase 5: Managing with Docker Compose # With more services, orchestration becomes important. Enter Docker Compose.\nYouâ€™ll Learn:\nDefining multi-service environments in docker-compose.yml Networking between services Simplifying development and testing ğŸš¢ Phase 6: Orchestration with Docker Swarm (Optional) # For real-world scalability, we use Docker Swarm to orchestrate services across a cluster.\nYouâ€™ll Learn:\nSetting up a Swarm cluster Deploying services in a distributed fashion Achieving high availability and self-healing systems ğŸ§  Group Presentation on System Design # In this collaborative exercise, teams will tackle real-world system design challenges that scale from hundreds to millions of users. Each team will:\nSelect a Scalable Project: Choose from industry-relevant scenarios like social media timelines, URL shorteners, or distributed search engines Create a Multi-Stage Scaling Plan: Design architecture that evolves through three growth stages (1K â†’ 100K â†’ 1M+ users) Specify Technical Components: Detail infrastructure, databases, caching strategies, API design, and monitoring solutions Present with Diagrams: Deliver a comprehensive presentation with architecture diagrams, justifications for design choices, and analysis of potential failure points Teams will be evaluated on their application of distributed systems principles, scalability considerations, and technical communication skills.\nğŸ“š Group Presentation on Industry Trendy Distributed Systems # Teams will deeply explore modern distributed technologies that power today\u0026rsquo;s scalable applications. For this presentation:\nResearch \u0026amp; Analyze: Thoroughly investigate an assigned distributed system technology (e.g., Cassandra, Kafka, Redis Cluster, Etcd, Consul, CockroachDB, or MinIO) Document Key Aspects: Architecture: Core components and structural design Working Principles: Algorithms and data flow mechanisms High Availability: Failure handling and redundancy approaches Use Cases: Optimal application scenarios and problem domains Integration: How it fits within microservices ecosystems Deliver Engaging Presentation: Share insights with peers and faculty, emphasizing practical applications Presentations should reinforce understanding of consistency models, consensus protocols, data partitioning, and state management in distributed systems.\nğŸ“ Final Outcome # By the end of this lab, you will have:\nBuilt and deployed a functional microservices application Practiced containerization and orchestration Understood the real-world workflow of backend and DevOps engineering Strengthened your system design thinking Ready to build your first distributed system? Letâ€™s dive in! ğŸš€\n"},{"id":1,"href":"/docs/timeline/","title":"Course Timeline","section":"Docs","content":" ğŸ“… Course Timeline \u0026amp; Milestones # This timeline provides a week-by-week breakdown of the course, showing lecture topics and corresponding assignments. The course is designed to progressively build your distributed systems skills from fundamentals to advanced orchestration.\nğŸ—“ï¸ Weekly Schedule # Week Lecture Topics Lab Assignment Deliverables 1 Microservices Fundamentals â€¢ Introduction to distributed systemsâ€¢ Monolithic vs microservices architecture Phase 1: Monolithic Smart Library System Working monolithic application 2-3 Transition to Microservices â€¢ Service decomposition strategiesâ€¢ Inter-service communicationâ€¢ Phase 1 evaluation \u0026amp; feedback Phase 2: Microservices Implementation Multiple independent services with API endpoints 4-5 API Gateway \u0026amp; Reverse Proxy â€¢ Nginx configuration \u0026amp; deploymentâ€¢ Load balancing strategiesâ€¢ Phase 2 evaluation \u0026amp; feedback Phase 3: Nginx Integration Centralized access point with proper routing 6-7 Containerization â€¢ Docker fundamentalsâ€¢ Container networkingâ€¢ Phase 3 evaluation \u0026amp; feedback Phase 4: Docker Implementation Containerized services with proper isolation 8-9 Container Orchestration Basics â€¢ Docker Compose workflowsâ€¢ Multi-container applicationsâ€¢ Phase 4 evaluation \u0026amp; feedback Phase 5: Docker Compose Setup Multi-container application with defined dependencies 10 Advanced Orchestration â€¢ Docker Swarm architectureâ€¢ Service scaling \u0026amp; managementâ€¢ Phase 5 evaluation \u0026amp; feedback Group Presentations: Design \u0026amp; Documentation Project proposal \u0026amp; architecture diagram 11 System Design Principles â€¢ Scalability patternsâ€¢ High availability strategies Group Presentations: Implementation \u0026amp; documentation Progress report \u0026amp; technical documentation 12-13 Group Presentations â€¢ System design presentationsâ€¢ Industry trendy distributed systems showcase Group Presentations: Finalization \u0026amp; presentation prep Final presentation slides \u0026amp; demo 14 Course Review \u0026amp; Final Evaluation â€¢ Best practices reviewâ€¢ Industry application discussion Final Assessment Course completion \u0026amp; project evaluation ğŸ“Š Grading Distribution # Individual Lab Phases (1-5): Each phase will be evaluated based on functionality, code quality, and documentation. Detailed rubric will be published soon. Group Project \u0026amp; Presentation: Assessment will focus on system design principles, technical implementation, and presentation quality. Detailed evaluation criteria will be shared before Week 10. ğŸ” Important Notes # Each phase builds upon the previous one, creating a complete learning journey Evaluations occur regularly to provide feedback and guidance Group work begins in Week 10, allowing sufficient time for comprehensive research and implementation Final presentations should demonstrate both technical mastery and effective communication "},{"id":2,"href":"/docs/prerequisites/","title":"Prerequisites","section":"Docs","content":" ğŸ“‹ Prerequisites # Before diving into the Smart Library System project, itâ€™s important to ensure that students or participants have the foundational knowledge and hands-on exposure to the following areas:\nğŸŒ 1. Basic Understanding of Web Application \u0026amp; Development # Understand the client-server model. Familiarity with how a web application works (browser â†’ server â†’ database). Concept of HTTP verbs: GET, POST, PUT, DELETE, etc. Awareness of RESTful API principles: Resource-oriented endpoints Stateless communication Uniform interface ğŸ”§ 2. API Development in Any Language # Participants should have prior experience with creating APIs in any programming language.\nğŸ’¡ Reference: Check out the ğŸ› ï¸ Tools \u0026amp; Technology Stack section for supported languages and frameworks (Python, Node.js, Java, C#).\nMinimum experience includes:\nRouting \u0026amp; endpoint creation Accepting and parsing JSON input Sending JSON responses Status codes (200 OK, 400 Bad Request, etc.) ğŸ—ƒï¸ 3. Basic Database Understanding # Familiarity with relational databases such as PostgreSQL, MySQL, or MSSQL.\nStudents should know:\nCreating tables and defining schema Performing CRUD operations: SELECT, INSERT, UPDATE, DELETE Concepts like: Primary keys Foreign keys Relationships (one-to-many, many-to-many) ğŸ”Œ 4. Database Integration with Backend # Experience connecting an application to a database, such as:\nUsing ORM (like SQLAlchemy, TypeORM, Hibernate, EF Core) Writing raw SQL queries or using query builders Handling database migrations (bonus) Performing DB transactions inside the application code ğŸ” 5. API Testing Skills # Comfortable with using tools like Postman or Bruno to:\nSend requests to an API Provide JSON body and headers View responses and validate status codes Automate collections for repeated tests ğŸ’¡ For tools, see: API Testing Tools\nğŸ 6. Debugging Experience # The ability to identify and troubleshoot bugs during development.\nThis includes:\nReading and understanding stack traces Using logging tools or breakpoints (e.g., print, console.log, logger.debug()) Fixing common backend issues: DB connection errors Invalid input handling Unhandled exceptions âœ… Note: These skills will ensure a smoother experience throughout the project and allow participants to focus on designing scalable microservices rather than struggling with basic development issues.\n"},{"id":3,"href":"/docs/tools/","title":"Tools","section":"Docs","content":" ğŸ› ï¸ Tools \u0026amp; Technology Stack # This section outlines the recommended tools, frameworks, and platforms used in building and testing the Smart Library System (Microservices Architecture).\nğŸš€ Language \u0026amp; Framework Preferences # Choose any language or framework from below, depending on your expertise or lab instruction:\nğŸ Python # Framework Description FastAPI High-performance, modern API framework using ASGI. Ideal for microservices. Flask Lightweight WSGI framework. Easy to use, good for learning microservice patterns. Django Full-featured web framework. Use with Django REST Framework for API-based microservices. ğŸŒ Node.js # Framework Description Express.js Minimal and flexible framework for building REST APIs. Fast and widely used. â˜• Java # Framework Description Spring Boot Production-grade microservice framework with robust dependency injection and JPA support. ğŸ§± C# # Framework Description .NET Core / ASP.NET Core Cross-platform microservice-ready framework by Microsoft. Supports REST APIs out-of-the-box. ğŸŒ API Testing Tools # Tool Purpose Postman Powerful GUI for testing REST APIs. Bruno Open-source and developer-friendly API testing alternative to Postman. ğŸ§ Preferred Operating System # OS Version Description Ubuntu 22.04 LTS Long-Term Support, stable and widely used in cloud environments. Ubuntu 24.04 LTS (Upcoming/Recent) Updated LTS version with latest packages. ğŸ—ƒï¸ Preferred Databases # Choose your preferred RDBMS per service â€” all options are supported:\nDatabase Notes PostgreSQL Open-source, feature-rich, and widely used in production. MySQL Lightweight, easy to use, and fast. MSSQL Great for enterprise-grade applications using .NET Core. Each microservice will own its own dedicated database instance.\nğŸ” Database Browsing \u0026amp; Inspection Tools # Tool Description DataGrip Universal database IDE by JetBrains (supports all major RDBMS). pgAdmin PostgreSQLâ€™s official web-based admin interface. "},{"id":4,"href":"/docs/phase-1/","title":"Phase 1","section":"Docs","content":" ğŸ“˜ Smart Library System â€“ Monolithic Architecture # Overview # The Smart Library System (Monolithic Version) is a single, unified application that handles all core functionalities: managing users, books, and book loans. This system is ideal for simple deployments where all components are tightly coupled, sharing the same runtime and database.\nğŸ§© Functional Modules # 1. User Management Module # Register a user (students/faculty). Update user profile. Retrieve user info. 2. Book Management Module # Add/update/remove books. View book availability. Search books by title, author, or genre. 3. Loan Management Module # Issue books to users. Return books. View active/past loans. ğŸ›¢ï¸ Unified Database Schema # Table Description users Stores user information. books Stores book catalog details. loans Tracks issued/returned books. All modules interact with this shared relational database, typically PostgreSQL or MySQL.\nğŸ”„ Internal Communication # All module calls happen via function calls or internal classes. Tight coupling between modules. No network-based interaction â€” all components reside in the same codebase and memory space. ğŸ§ª Example API Documentation (REST Endpoints) # Hereâ€™s how external clients (like CLI tools or a potential frontend) interact with the system.\nğŸ”¹ User Endpoints # POST /api/users # Create/register a new user.\n{ \u0026#34;name\u0026#34;: \u0026#34;Alice Smith\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;alice@example.com\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;student\u0026#34; } GET /api/users/{id} # Fetch user profile by ID.\nğŸ”¹ Book Endpoints # POST /api/books # Add a new book.\n{ \u0026#34;title\u0026#34;: \u0026#34;Clean Code\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Robert C. Martin\u0026#34;, \u0026#34;isbn\u0026#34;: \u0026#34;9780132350884\u0026#34;, \u0026#34;copies\u0026#34;: 3 } GET /api/books?search=clean # Search for books by title, author, or keyword.\nğŸ”¹ Loan Endpoints # POST /api/loans # Issue a book to a user.\n{ \u0026#34;user_id\u0026#34;: 1, \u0026#34;book_id\u0026#34;: 42 } POST /api/returns # Return a borrowed book.\n{ \u0026#34;loan_id\u0026#34;: 1001 } GET /api/loans/{user_id} # View loan history for a user.\nâš ï¸ Limitations of Monolithic Design # Hard to scale individual components independently. Tight coupling makes it difficult to change or test modules in isolation. Single point of failure: one bug can crash the entire app. Deployment of small changes requires redeploying the whole system. "},{"id":5,"href":"/docs/phase-2/","title":"Phase 2","section":"Docs","content":" ğŸ§© Smart Library System â€“ Microservices Architecture # Overview # In the microservices version of the Smart Library System, the application is divided into three independent services â€” each responsible for a specific domain: User, Book, and Loan. Every service has its own database and communicates with others via HTTP APIs (no queues or Kafka involved in this version).\nğŸ§± Services Overview # 1. User Service # Handles registration, profile management, and user-related queries.\nğŸšª REST Base Path: /api/users ğŸ“¦ Owns a user database. ğŸ”¹ API Endpoints # POST /api/users # Register a new user.\n{ \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;alice@example.com\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;student\u0026#34; } GET /api/users/{id} # Fetch user details by ID.\n2. Book Service # Manages book inventory, search, and updates to availability.\nğŸšª REST Base Path: /api/books ğŸ“¦ Owns a book database. ğŸ”¹ API Endpoints # POST /api/books # Add a new book.\n{ \u0026#34;title\u0026#34;: \u0026#34;Clean Code\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Robert C. Martin\u0026#34;, \u0026#34;isbn\u0026#34;: \u0026#34;9780132350884\u0026#34;, \u0026#34;copies\u0026#34;: 3 } GET /api/books?search=code # Search books by title, author, or keyword.\nPATCH /api/books/{id} # Update a book\u0026rsquo;s available copies (used by Loan Service during issue/return).\n{ \u0026#34;copies\u0026#34;: 2 } 3. Loan Service # Issues and returns books by communicating with both User Service and Book Service.\nğŸšª REST Base Path: /api/loans ğŸ“¦ Owns a loan database. ğŸ”¹ API Endpoints # POST /api/loans # Create a loan.\n{ \u0026#34;user_id\u0026#34;: 1, \u0026#34;book_id\u0026#34;: 42 } Process:\nValidate user_id via User Service. Validate book_id and availability via Book Service. If all checks pass, reduce the book\u0026rsquo;s available copy count. POST /api/returns # Return a borrowed book.\n{ \u0026#34;loan_id\u0026#34;: 1001 } Process:\nUpdate loan status. Increment book availability in Book Service. GET /api/loans/user/{user_id} # Get a user\u0026rsquo;s loan history (active and returned books).\nğŸ”— Inter-Service Communication # Loan Service makes HTTP calls to: User Service: to validate user identity. Book Service: to check and update book inventory. No shared database. Each service is data-isolated for decoupling and autonomy.\nğŸ›¢ï¸ Databases (One per service) # Service Database Tables User Service user_db users Book Service book_db books Loan Service loan_db loans âš™ï¸ Deployment Strategy # Each microservice:\nRuns in its own container or VM. Has its own codebase, tests, deployment pipeline. Can be updated, scaled, or restarted independently. âœ… Advantages of Microservices # Independent development and deployment. Fault isolation: one service failing doesnâ€™t crash the whole app. Easier scaling: Book Service can be scaled independently if traffic spikes. âš ï¸ Trade-offs # Increased operational complexity. Requires robust service discovery, monitoring, and API versioning. Debugging across services can be harder without centralized logs. "},{"id":6,"href":"/docs/phase-3/","title":"Phase 3","section":"Docs","content":" ğŸŒ Phase 3: Reverse Proxy with Nginx # This phase introduces Nginx as a reverse proxy, acting as the single entry point to route traffic to backend microservices.\nğŸ¯ Youâ€™ll Learn: # What is a reverse proxy and why it\u0026rsquo;s important Routing and load balancing strategies How to serve APIs and static content behind Nginx Configuring HTTPS (SSL termination) ğŸ›  Topics Covered: # Installing and configuring Nginx on Linux nginx.conf structure and virtual hosts Path-based routing: /api/users â†’ User Service /api/books â†’ Book Service /api/loans â†’ Loan Service Static file delivery for frontend (optional) Logging requests centrally Handling 404s and upstream errors "},{"id":7,"href":"/docs/phase-4/","title":"Phase 4","section":"Docs","content":" ğŸ³ Phase 4: Containerization with Docker # We encapsulate each microservice into its own Docker container to achieve environment consistency and portability.\nğŸ¯ Youâ€™ll Learn: # Why containerization is essential in microservice ecosystems How to write Dockerfiles for Python, Node.js, Java, and .NET Core apps How to build and run containers Container networking and volume mounting ğŸ›  Topics Covered: # Writing Dockerfiles for each service Installing dependencies inside containers Exposing ports and configuring environment variables Docker CLI basics: build, run, exec, logs Creating named networks for communication between services "},{"id":8,"href":"/docs/phase-5/","title":"Phase 5","section":"Docs","content":" âš™ï¸ Phase 5: Managing with Docker Compose # With multiple services running, we now use Docker Compose to manage them together through a unified configuration.\nğŸ¯ Youâ€™ll Learn: # Structuring a docker-compose.yml file Defining services, networks, and volumes Scaling services for development/testing Making services talk to each other by name ğŸ›  Topics Covered: # Docker Compose syntax and service definitions Declaring DB containers (e.g., Postgres, MySQL) Health checks and restart policies Local development workflows with Compose Mounting source code with volumes: for live reloading "},{"id":9,"href":"/docs/phase-6/","title":"Phase 6","section":"Docs","content":" ğŸš¢ Phase 6: Orchestration with Docker Swarm (Optional) # Once youâ€™ve mastered local development, we introduce Docker Swarm for distributed service orchestration.\nğŸ¯ Youâ€™ll Learn: # Running your app on a multi-node Docker cluster Service scaling, rolling updates, and high availability Managing load balancing and service discovery ğŸ›  Topics Covered: # Initializing a Docker Swarm (docker swarm init) Creating overlay networks Deploying stacks via docker stack deploy Scaling services with replicas Monitoring service health and logs ğŸ” Optional Lab: Simulate node failure and observe Swarm\u0026rsquo;s self-healing\n"},{"id":10,"href":"/docs/system-design/","title":"Systems Design Problems","section":"Docs","content":" ğŸ—ï¸ System Design at Scale # Overview # In this phase, we\u0026rsquo;ll tackle the challenge of designing systems that can scale from hundreds to millions of users. Students will work in teams to develop comprehensive system architectures that demonstrate an understanding of distributed systems principles in real-world scenarios.\nğŸ“‹ Learning Objectives # Apply distributed systems concepts to practical, industry-relevant problems Design scalable architectures that evolve with increasing user demands Identify and resolve bottlenecks in system performance Make informed trade-offs between consistency, availability, and partition tolerance Document and present technical designs effectively ğŸ”„ Methodology # Each team will:\nSelect a Project: Choose from the example projects listed below Design in Stages: Create a three-stage scaling plan: Stage 1: Initial design for minimal viable product (~1,000 users) Stage 2: Enhanced design for moderate growth (~100,000 users) Stage 3: Full-scale architecture for massive adoption (~1,000,000+ users) Document Components: For each stage, specify: Infrastructure requirements (servers, load balancers, CDNs) Database choices and data modeling approaches Caching strategies and implementation API design and service boundaries Monitoring and observability solutions Present Solutions: Deliver a comprehensive presentation with diagrams, justifications for design choices, and analysis of potential failure points ğŸš€ Example Projects # Each project presents unique scaling challenges that will test your understanding of distributed systems:\nProject Key Challenges 1. Twitter Timeline \u0026amp; Search Real-time updates, high read throughput, efficient search indexing 2. URL Shortener (like Bit.ly) High availability, redirect performance, analytics tracking 3. Personal Finance App (like Mint.com) Data security, third-party integrations, background processing 4. Social Network Data Structure Complex relationships, feed generation, privacy controls 5. Search Engine Key-Value Store Distributed indexing, query optimization, fault tolerance 6. E-commerce Category Rankings Real-time analytics, caching strategies, consistency requirements 7. Web Crawler Distributed work coordination, politeness policies, data processing pipeline ğŸ“š Resources # System Design Primer - Comprehensive resource for system design concepts AWS Scaling Example - Reference implementation for scaling on AWS System Design - Recommended reading for System Design Advanced System Design - Recommended reading for Advance System Design "},{"id":11,"href":"/docs/exploration/","title":"Some Distributed Systems Exploration","section":"Docs","content":" ğŸŒ Distributed Systems Exploration # Distributed systems are the backbone of scalable and fault-tolerant applications. In this phase, we explore 6+ distributed technologies, understanding how they work, what problems they solve, and where they fit in microservices.\nğŸ” Exploration Methodology # For this phase, students will work in collaborative teams to deeply investigate distributed systems technologies. Each team will:\nResearch \u0026amp; Analyze: Thoroughly explore an assigned distributed system technology Document Findings: Create comprehensive technical documentation Present Solutions: Deliver an engaging presentation to peers and faculty Your exploration should focus on these key aspects:\nFocus Area Key Questions to Address ğŸ—ï¸ Architecture How is the system structured? What are its core components? âš™ï¸ Working Principles What algorithms and techniques make it function? How does data flow? ğŸ›¡ï¸ High Availability How does it handle failures? What redundancy mechanisms exist? ğŸ’¼ Use Cases Where is it most effectively applied? What problems does it solve best? ğŸ”„ Integration How does it fit within a microservices ecosystem? Teams will be evaluated on technical depth, presentation quality, and practical insights provided.\nğŸ“¦ 1. Apache Cassandra â€“ Decentralized NoSQL DB # Architecture Highlights:\nPeer-to-peer ring-based system using consistent hashing Eventual consistency with tunable quorum reads/writes Replication across data centers Uses SSTables and Memtables for fast write-heavy workloads Use Case: High-volume write system for analytics or logs.\nâš¡ 2. Apache Kafka â€“ Distributed Event Streaming Platform # Architecture Highlights:\nDistributed commit log with partitioned topics Producer â†’ Kafka Broker â†’ Consumer Message durability via segment files on disk High-throughput stream processing with horizontal scaling Use Case: Decoupled microservice communication, event sourcing, stream analytics.\nğŸ§  3. Redis Cluster â€“ In-Memory Key-Value Store (Distributed Mode) # Architecture Highlights:\nHash-slot-based sharding (16,384 slots) Master-replica architecture with automatic failover (via Sentinel or Cluster) High-speed data access with optional persistence Use Case: Caching for microservices, pub/sub for chat or real-time updates.\nğŸ§® 4. Etcd â€“ Distributed Key-Value Store for Configuration \u0026amp; Coordination # Architecture Highlights:\nStrongly consistent store using Raft consensus Frequently used in Kubernetes for state/config storage Designed for leader election, distributed locking, and configuration management Use Case: Service registry, feature flag storage, cluster coordination.\nğŸ” 5. Consul â€“ Service Discovery and Key/Value Configuration # Architecture Highlights:\nGossip-based peer discovery Offers DNS + HTTP APIs for service registration and health checking KV store with ACLs for configuration sharing Integrates with Envoy for service mesh features Use Case: Discover microservices dynamically, share config globally across services.\nğŸŒ 6. CockroachDB â€“ Distributed SQL Database # Architecture Highlights:\nFollows Google Spanner-inspired architecture Distributed ACID transactions via Raft Multi-region, horizontally scalable SQL Strong consistency with PostgreSQL compatibility Use Case: Global backend for services needing relational queries and strong consistency.\nğŸ“˜ 7. MinIO â€“ Distributed Object Storage (S3-Compatible) # Architecture Highlights:\nDistributed erasure-coded storage Horizontal scaling with node auto-discovery API-compatible with AWS S3 High-performance object store for cloud-native workloads Use Case: Store file uploads, logs, media in a microservices app without relying on AWS.\nğŸ”„ Summary Table # System Type Architecture Keywords Ideal Use Case Cassandra NoSQL DB Peer-to-peer, AP, Sharding High-speed writes, analytics Kafka Event Streaming Broker, Partitioning, Log Messaging, decoupling, events Redis Cluster In-Memory KV Store Sharding, Replication Caching, real-time data Etcd Config Store Raft, Leader Election Cluster state/config (e.g., Kubernetes) Consul Service Discovery/KV Gossip, DNS-based discovery Microservices service registry CockroachDB Distributed SQL DB Raft, ACID, SQL + Scale Transactional workloads, global apps MinIO Object Storage Erasure coding, S3 API Distributed storage for files/media ğŸ§  Concepts Reinforced: # Consistency models (Strong, Eventual, Tunable) Consensus protocols (Raft, Gossip) Data partitioning and replication Service coordination and discovery State management in stateless systems "},{"id":12,"href":"/docs/career-path/","title":"Career Path","section":"Docs","content":" ğŸŒ Career Path # ğŸš€ Why Distributed Systems Matter for Your Career # The skills you\u0026rsquo;re developing in this Distributed Systems course are foundational to some of the most in-demand and well-compensated roles in the technology industry. As systems continue to scale and organizations embrace cloud-native architectures, professionals who understand distributed systems concepts are increasingly valuable.\nğŸ” From Academic Concepts to Industry Roles # This course introduces you to concepts and technologies that directly translate to professional roles such as:\nRole Connection to This Course DevOps Engineer Container orchestration, CI/CD, infrastructure automation Site Reliability Engineer (SRE) System design, fault tolerance, observability Platform Engineer Microservices architecture, API design, service mesh Cloud Engineer/Architect Distributed databases, scalability patterns, multi-region deployments ğŸ’¼ Key Responsibilities in These Roles # If you find yourself particularly interested in the topics covered in this course, you might consider exploring these career paths further:\nDevOps Engineer # Design and implement CI/CD pipelines Manage container orchestration platforms (Kubernetes, Docker Swarm) Automate infrastructure provisioning and configuration Implement monitoring and alerting solutions Optimize deployment workflows and application performance Site Reliability Engineer (SRE) # Design systems for reliability and fault tolerance Implement observability solutions (logging, monitoring, tracing) Create and maintain service level objectives (SLOs) Perform capacity planning and performance optimization Develop automation for incident response and recovery Platform Engineer # Design and build internal developer platforms Create reusable infrastructure components and services Implement service discovery and API gateways Manage service mesh implementations Develop self-service tools for development teams Cloud Engineer/Architect # Design multi-region, highly available architectures Implement cloud-native solutions using managed services Optimize for cost, performance, and security Develop disaster recovery and business continuity plans Create infrastructure as code (IaC) templates ğŸ—ºï¸ Your Learning Roadmap # The topics in this course align closely with the industry-standard DevOps Roadmap, which outlines the skills and technologies professionals need in these roles.\nRemember that the hands-on experience you gain in this lab is invaluableâ€”employers in these fields prioritize practical skills and problem-solving ability over theoretical knowledge alone.\n\u0026ldquo;The most valuable engineers are those who understand not just how to use tools, but why those tools exist and the problems they solve.\u0026rdquo; â€” Google SRE Book\n"},{"id":13,"href":"/docs/about-me/","title":"About Me","section":"Docs","content":" ğŸ‘¨â€ğŸ’» About Me # Hello! Iâ€™m Mohibul Alam, a passionate and hands-on Senior DevOps Engineer with a strong background in cloud infrastructure, automation, and modern backend systems. I bring almost 4 years of experience designing and deploying scalable, secure, and high-performance solutions across AWS, Azure, and on-premises environments.\nMy expertise lies in DevOps automation, container orchestration, observability, and backend development, with a growing interest in building intelligent systems powered by LLMs and AI agents.\nI am deeply involved in teaching and mentoring around cloud-native development and microservice architectures, and I actively contribute to building clean, efficient lab environments for students and professionals to explore real-world DevOps practices.\nğŸ§  What I Do # Architect and automate cloud infrastructure using Terraform, CDK, and CI/CD pipelines Deploy and manage Docker and Kubernetes environments for high availability Monitor systems with tools like Prometheus, Grafana, Tempo, and Loki Develop backend APIs using Python (FastAPI) and serverless platforms like AWS Lambda Build AI-driven applications with LLM frameworks like Promptflow, LlamaIndex, and Semantic Kernel Mentor students and junior engineers in modern software engineering practices ğŸ“ Education # BSc in Software Engineering\nUniversity of Dhaka, Bangladesh\nGraduated: 2022\nğŸ“œ Certifications # ğŸ† AWS Certified Solutions Architect â€“ Associate (SAA-C03) ğŸ›  Certified Kubernetes Application Developer (CKAD) ğŸ”— Find Me Online # LinkedIn GitHub Medium "},{"id":14,"href":"/docs/lecture-resources/lecture-1/ds/","title":"Distributed Systems","section":"Lecture 1: Introduction","content":" Introduction to Distributed Systems # âœ¨What is a Distributed System? # A distributed system is a collection of independent computers that appear to the user as a single system.\nğŸ‘‰ Even though they are separate machines, they work together to accomplish a task.\nReal-World Analogy: # Imagine a group project in university. You and 3 of your friends are working together on a research paper. Each of you is sitting in different homes (different computers). You split the work: ğŸ‘‰ One researches, ğŸ‘‰ One writes, ğŸ‘‰ One creates diagrams, ğŸ‘‰ One edits and checks.\nYou communicate over phone calls, texts, or video calls (network communication). To the teacher, you submit one single project (appears as one final product). ğŸ”µ Even though you worked separately, it looks like one single team produced it. â†’ That\u0026rsquo;s a distributed system!\nKey Characteristics (Visual): # Feature | Analogy | Description Multiple Computers | Different homes | Computers are physically separate. Work Together | Coordinated tasks | They have to communicate and divide the work. Communication | Phone calls, messages | They send data over the network. Looks Unified | One final report | To users, it feels like one single system.\nMore Everyday Examples: # Google Search : Billions of computers worldwide cooperate to quickly answer your search in milliseconds.\nNetflix : Different servers stream different parts of a movie to you, but it feels like one smooth video.\nOnline Multiplayer Games : Different servers manage player locations, actions, and events, but you feel like you\u0026rsquo;re in one continuous game world.\n"}]