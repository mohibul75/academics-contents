[{"id":0,"href":"/docs/details/","title":"Details","section":"Docs","content":" ğŸ“š Distributed Systems Lab â€” Detailed Breakdown # This lab is structured as a step-by-step journey through the lifecycle of building a distributed system with microservices.\nğŸš€ Phase 1: Monolithic Smart Library System # We begin with a monolithic design, where all components of the system reside in a single codebase.\nYouâ€™ll Learn:\nHow to structure a monolithic application Why monoliths become difficult to scale and maintain Building core modules: Users, Catalog, Borrowing Separation of concerns: Controller â†’ Service â†’ Repository layers ğŸ§© Phase 2: Transition to Microservices # Next, we break down the monolith into independently deployable microservices.\nYouâ€™ll Learn:\nHow to decompose services by business capability RESTful API communication between services Managing independent data sources Principles of loose coupling and bounded context ğŸŒ Phase 3: Reverse Proxy with Nginx # We introduce Nginx to centralize and manage access to microservices.\nYouâ€™ll Learn:\nHow reverse proxies work Nginx configuration for routing and load balancing Handling HTTPS and static files with Nginx Benefits of centralized access control and logging ğŸ³ Phase 4: Containerization with Docker # Now we containerize each service to ensure consistency across environments.\nYouâ€™ll Learn:\nWriting Dockerfiles for services Managing containers, images, and networks Creating isolated environments for each service âš™ï¸ Phase 5: Managing with Docker Compose # With more services, orchestration becomes important. Enter Docker Compose.\nYouâ€™ll Learn:\nDefining multi-service environments in docker-compose.yml Networking between services Simplifying development and testing ğŸš¢ Phase 6: Orchestration with Docker Swarm # For real-world scalability, we use Docker Swarm to orchestrate services across a cluster.\nYouâ€™ll Learn:\nSetting up a Swarm cluster Deploying services in a distributed fashion Achieving high availability and self-healing systems ğŸ§  Bonus Topics: System Design # Distributed systems are more than code â€” theyâ€™re about design. Weâ€™ll embed the following concepts throughout the lab:\nCAP Theorem and trade-offs Designing for fault tolerance Scaling strategies (horizontal vs vertical) Caching and database patterns Observability and metrics ğŸ“ Final Outcome # By the end of this lab, you will have:\nBuilt and deployed a functional microservices application Practiced containerization and orchestration Understood the real-world workflow of backend and DevOps engineering Strengthened your system design thinking Ready to build your first distributed system? Letâ€™s dive in! ğŸš€\n"},{"id":1,"href":"/docs/phase-1/","title":"Phase 1","section":"Docs","content":" ğŸ“˜ Smart Library System â€“ Monolithic Architecture # Overview # The Smart Library System (Monolithic Version) is a single, unified application that handles all core functionalities: managing users, books, and book loans. This system is ideal for simple deployments where all components are tightly coupled, sharing the same runtime and database.\nğŸ§© Functional Modules # 1. User Management Module # Register a user (students/faculty). Update user profile. Retrieve user info. 2. Book Management Module # Add/update/remove books. View book availability. Search books by title, author, or genre. 3. Loan Management Module # Issue books to users. Return books. View active/past loans. ğŸ›¢ï¸ Unified Database Schema # Table Description users Stores user information. books Stores book catalog details. loans Tracks issued/returned books. All modules interact with this shared relational database, typically PostgreSQL or MySQL.\nğŸ”„ Internal Communication # All module calls happen via function calls or internal classes. Tight coupling between modules. No network-based interaction â€” all components reside in the same codebase and memory space. ğŸ§ª Example API Documentation (REST Endpoints) # Hereâ€™s how external clients (like CLI tools or a potential frontend) interact with the system.\nğŸ”¹ User Endpoints # POST /api/users # Create/register a new user.\n{ \u0026#34;name\u0026#34;: \u0026#34;Alice Smith\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;alice@example.com\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;student\u0026#34; } GET /api/users/{id} # Fetch user profile by ID.\nğŸ”¹ Book Endpoints # POST /api/books # Add a new book.\n{ \u0026#34;title\u0026#34;: \u0026#34;Clean Code\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Robert C. Martin\u0026#34;, \u0026#34;isbn\u0026#34;: \u0026#34;9780132350884\u0026#34;, \u0026#34;copies\u0026#34;: 3 } GET /api/books?search=clean # Search for books by title, author, or keyword.\nğŸ”¹ Loan Endpoints # POST /api/loans # Issue a book to a user.\n{ \u0026#34;user_id\u0026#34;: 1, \u0026#34;book_id\u0026#34;: 42 } POST /api/returns # Return a borrowed book.\n{ \u0026#34;loan_id\u0026#34;: 1001 } GET /api/loans/{user_id} # View loan history for a user.\nâš ï¸ Limitations of Monolithic Design # Hard to scale individual components independently. Tight coupling makes it difficult to change or test modules in isolation. Single point of failure: one bug can crash the entire app. Deployment of small changes requires redeploying the whole system. "},{"id":2,"href":"/docs/phase-2/","title":"Phase 2","section":"Docs","content":" ğŸ§© Smart Library System â€“ Microservices Architecture # Overview # In the microservices version of the Smart Library System, the application is divided into three independent services â€” each responsible for a specific domain: User, Book, and Loan. Every service has its own database and communicates with others via HTTP APIs (no queues or Kafka involved in this version).\nğŸ§± Services Overview # 1. User Service # Handles registration, profile management, and user-related queries.\nğŸšª REST Base Path: /api/users ğŸ“¦ Owns a user database. ğŸ”¹ API Endpoints # POST /api/users # Register a new user.\n{ \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;alice@example.com\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;student\u0026#34; } GET /api/users/{id} # Fetch user details by ID.\n2. Book Service # Manages book inventory, search, and updates to availability.\nğŸšª REST Base Path: /api/books ğŸ“¦ Owns a book database. ğŸ”¹ API Endpoints # POST /api/books # Add a new book.\n{ \u0026#34;title\u0026#34;: \u0026#34;Clean Code\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Robert C. Martin\u0026#34;, \u0026#34;isbn\u0026#34;: \u0026#34;9780132350884\u0026#34;, \u0026#34;copies\u0026#34;: 3 } GET /api/books?search=code # Search books by title, author, or keyword.\nPATCH /api/books/{id} # Update a book\u0026rsquo;s available copies (used by Loan Service during issue/return).\n{ \u0026#34;copies\u0026#34;: 2 } 3. Loan Service # Issues and returns books by communicating with both User Service and Book Service.\nğŸšª REST Base Path: /api/loans ğŸ“¦ Owns a loan database. ğŸ”¹ API Endpoints # POST /api/loans # Create a loan.\n{ \u0026#34;user_id\u0026#34;: 1, \u0026#34;book_id\u0026#34;: 42 } Process:\nValidate user_id via User Service. Validate book_id and availability via Book Service. If all checks pass, reduce the book\u0026rsquo;s available copy count. POST /api/returns # Return a borrowed book.\n{ \u0026#34;loan_id\u0026#34;: 1001 } Process:\nUpdate loan status. Increment book availability in Book Service. GET /api/loans/user/{user_id} # Get a user\u0026rsquo;s loan history (active and returned books).\nğŸ”— Inter-Service Communication # Loan Service makes HTTP calls to: User Service: to validate user identity. Book Service: to check and update book inventory. No shared database. Each service is data-isolated for decoupling and autonomy.\nğŸ›¢ï¸ Databases (One per service) # Service Database Tables User Service user_db users Book Service book_db books Loan Service loan_db loans âš™ï¸ Deployment Strategy # Each microservice:\nRuns in its own container or VM. Has its own codebase, tests, deployment pipeline. Can be updated, scaled, or restarted independently. âœ… Advantages of Microservices # Independent development and deployment. Fault isolation: one service failing doesnâ€™t crash the whole app. Easier scaling: Book Service can be scaled independently if traffic spikes. âš ï¸ Trade-offs # Increased operational complexity. Requires robust service discovery, monitoring, and API versioning. Debugging across services can be harder without centralized logs. "},{"id":3,"href":"/docs/tools/","title":"Tools","section":"Docs","content":" ğŸ› ï¸ Tools \u0026amp; Technology Stack # This section outlines the recommended tools, frameworks, and platforms used in building and testing the Smart Library System (Microservices Architecture).\nğŸš€ Language \u0026amp; Framework Preferences # Choose any language or framework from below, depending on your expertise or lab instruction:\nğŸ Python # Framework Description FastAPI High-performance, modern API framework using ASGI. Ideal for microservices. Flask Lightweight WSGI framework. Easy to use, good for learning microservice patterns. Django Full-featured web framework. Use with Django REST Framework for API-based microservices. ğŸŒ Node.js # Framework Description Express.js Minimal and flexible framework for building REST APIs. Fast and widely used. â˜• Java # Framework Description Spring Boot Production-grade microservice framework with robust dependency injection and JPA support. ğŸ§± C# # Framework Description .NET Core / ASP.NET Core Cross-platform microservice-ready framework by Microsoft. Supports REST APIs out-of-the-box. ğŸŒ API Testing Tools # Tool Purpose Postman Powerful GUI for testing REST APIs. Bruno Open-source and developer-friendly API testing alternative to Postman. ğŸ§ Preferred Operating System # OS Version Description Ubuntu 22.04 LTS Long-Term Support, stable and widely used in cloud environments. Ubuntu 24.04 LTS (Upcoming/Recent) Updated LTS version with latest packages. ğŸ—ƒï¸ Preferred Databases # Choose your preferred RDBMS per service â€” all options are supported:\nDatabase Notes PostgreSQL Open-source, feature-rich, and widely used in production. MySQL Lightweight, easy to use, and fast. MSSQL Great for enterprise-grade applications using .NET Core. Each microservice will own its own dedicated database instance.\nğŸ” Database Browsing \u0026amp; Inspection Tools # Tool Description DataGrip Universal database IDE by JetBrains (supports all major RDBMS). pgAdmin PostgreSQLâ€™s official web-based admin interface. "}]