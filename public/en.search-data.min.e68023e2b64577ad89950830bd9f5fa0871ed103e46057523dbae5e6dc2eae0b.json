[{"id":0,"href":"/docs/details/","title":"Details","section":"Docs","content":" 📚 Distributed Systems Lab — Detailed Breakdown # This lab is structured as a step-by-step journey through the lifecycle of building a distributed system with microservices.\n🚀 Phase 1: Monolithic Smart Library System # We begin with a monolithic design, where all components of the system reside in a single codebase.\nYou’ll Learn:\nHow to structure a monolithic application Why monoliths become difficult to scale and maintain Building core modules: Users, Catalog, Borrowing Separation of concerns: Controller → Service → Repository layers 🧩 Phase 2: Transition to Microservices # Next, we break down the monolith into independently deployable microservices.\nYou’ll Learn:\nHow to decompose services by business capability RESTful API communication between services Managing independent data sources Principles of loose coupling and bounded context 🌐 Phase 3: Reverse Proxy with Nginx # We introduce Nginx to centralize and manage access to microservices.\nYou’ll Learn:\nHow reverse proxies work Nginx configuration for routing and load balancing Handling HTTPS and static files with Nginx Benefits of centralized access control and logging 🐳 Phase 4: Containerization with Docker # Now we containerize each service to ensure consistency across environments.\nYou’ll Learn:\nWriting Dockerfiles for services Managing containers, images, and networks Creating isolated environments for each service ⚙️ Phase 5: Managing with Docker Compose # With more services, orchestration becomes important. Enter Docker Compose.\nYou’ll Learn:\nDefining multi-service environments in docker-compose.yml Networking between services Simplifying development and testing 🚢 Phase 6: Orchestration with Docker Swarm # For real-world scalability, we use Docker Swarm to orchestrate services across a cluster.\nYou’ll Learn:\nSetting up a Swarm cluster Deploying services in a distributed fashion Achieving high availability and self-healing systems 🧠 Bonus Topics: System Design # Distributed systems are more than code — they’re about design. We’ll embed the following concepts throughout the lab:\nCAP Theorem and trade-offs Designing for fault tolerance Scaling strategies (horizontal vs vertical) Caching and database patterns Observability and metrics 🎓 Final Outcome # By the end of this lab, you will have:\nBuilt and deployed a functional microservices application Practiced containerization and orchestration Understood the real-world workflow of backend and DevOps engineering Strengthened your system design thinking Ready to build your first distributed system? Let’s dive in! 🚀\n"},{"id":1,"href":"/docs/phase-1/","title":"Phase 1","section":"Docs","content":" 📘 Smart Library System – Monolithic Architecture # Overview # The Smart Library System (Monolithic Version) is a single, unified application that handles all core functionalities: managing users, books, and book loans. This system is ideal for simple deployments where all components are tightly coupled, sharing the same runtime and database.\n🧩 Functional Modules # 1. User Management Module # Register a user (students/faculty). Update user profile. Retrieve user info. 2. Book Management Module # Add/update/remove books. View book availability. Search books by title, author, or genre. 3. Loan Management Module # Issue books to users. Return books. View active/past loans. 🛢️ Unified Database Schema # Table Description users Stores user information. books Stores book catalog details. loans Tracks issued/returned books. All modules interact with this shared relational database, typically PostgreSQL or MySQL.\n🔄 Internal Communication # All module calls happen via function calls or internal classes. Tight coupling between modules. No network-based interaction — all components reside in the same codebase and memory space. 🧪 Example API Documentation (REST Endpoints) # Here’s how external clients (like CLI tools or a potential frontend) interact with the system.\n🔹 User Endpoints # POST /api/users # Create/register a new user.\n{ \u0026#34;name\u0026#34;: \u0026#34;Alice Smith\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;alice@example.com\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;student\u0026#34; } GET /api/users/{id} # Fetch user profile by ID.\n🔹 Book Endpoints # POST /api/books # Add a new book.\n{ \u0026#34;title\u0026#34;: \u0026#34;Clean Code\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Robert C. Martin\u0026#34;, \u0026#34;isbn\u0026#34;: \u0026#34;9780132350884\u0026#34;, \u0026#34;copies\u0026#34;: 3 } GET /api/books?search=clean # Search for books by title, author, or keyword.\n🔹 Loan Endpoints # POST /api/loans # Issue a book to a user.\n{ \u0026#34;user_id\u0026#34;: 1, \u0026#34;book_id\u0026#34;: 42 } POST /api/returns # Return a borrowed book.\n{ \u0026#34;loan_id\u0026#34;: 1001 } GET /api/loans/{user_id} # View loan history for a user.\n⚠️ Limitations of Monolithic Design # Hard to scale individual components independently. Tight coupling makes it difficult to change or test modules in isolation. Single point of failure: one bug can crash the entire app. Deployment of small changes requires redeploying the whole system. "},{"id":2,"href":"/docs/phase-2/","title":"Phase 2","section":"Docs","content":" 🧩 Smart Library System – Microservices Architecture # Overview # In the microservices version of the Smart Library System, the application is divided into three independent services — each responsible for a specific domain: User, Book, and Loan. Every service has its own database and communicates with others via HTTP APIs (no queues or Kafka involved in this version).\n🧱 Services Overview # 1. User Service # Handles registration, profile management, and user-related queries.\n🚪 REST Base Path: /api/users 📦 Owns a user database. 🔹 API Endpoints # POST /api/users # Register a new user.\n{ \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;alice@example.com\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;student\u0026#34; } GET /api/users/{id} # Fetch user details by ID.\n2. Book Service # Manages book inventory, search, and updates to availability.\n🚪 REST Base Path: /api/books 📦 Owns a book database. 🔹 API Endpoints # POST /api/books # Add a new book.\n{ \u0026#34;title\u0026#34;: \u0026#34;Clean Code\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Robert C. Martin\u0026#34;, \u0026#34;isbn\u0026#34;: \u0026#34;9780132350884\u0026#34;, \u0026#34;copies\u0026#34;: 3 } GET /api/books?search=code # Search books by title, author, or keyword.\nPATCH /api/books/{id} # Update a book\u0026rsquo;s available copies (used by Loan Service during issue/return).\n{ \u0026#34;copies\u0026#34;: 2 } 3. Loan Service # Issues and returns books by communicating with both User Service and Book Service.\n🚪 REST Base Path: /api/loans 📦 Owns a loan database. 🔹 API Endpoints # POST /api/loans # Create a loan.\n{ \u0026#34;user_id\u0026#34;: 1, \u0026#34;book_id\u0026#34;: 42 } Process:\nValidate user_id via User Service. Validate book_id and availability via Book Service. If all checks pass, reduce the book\u0026rsquo;s available copy count. POST /api/returns # Return a borrowed book.\n{ \u0026#34;loan_id\u0026#34;: 1001 } Process:\nUpdate loan status. Increment book availability in Book Service. GET /api/loans/user/{user_id} # Get a user\u0026rsquo;s loan history (active and returned books).\n🔗 Inter-Service Communication # Loan Service makes HTTP calls to: User Service: to validate user identity. Book Service: to check and update book inventory. No shared database. Each service is data-isolated for decoupling and autonomy.\n🛢️ Databases (One per service) # Service Database Tables User Service user_db users Book Service book_db books Loan Service loan_db loans ⚙️ Deployment Strategy # Each microservice:\nRuns in its own container or VM. Has its own codebase, tests, deployment pipeline. Can be updated, scaled, or restarted independently. ✅ Advantages of Microservices # Independent development and deployment. Fault isolation: one service failing doesn’t crash the whole app. Easier scaling: Book Service can be scaled independently if traffic spikes. ⚠️ Trade-offs # Increased operational complexity. Requires robust service discovery, monitoring, and API versioning. Debugging across services can be harder without centralized logs. "},{"id":3,"href":"/docs/tools/","title":"Tools","section":"Docs","content":" 🛠️ Tools \u0026amp; Technology Stack # This section outlines the recommended tools, frameworks, and platforms used in building and testing the Smart Library System (Microservices Architecture).\n🚀 Language \u0026amp; Framework Preferences # Choose any language or framework from below, depending on your expertise or lab instruction:\n🐍 Python # Framework Description FastAPI High-performance, modern API framework using ASGI. Ideal for microservices. Flask Lightweight WSGI framework. Easy to use, good for learning microservice patterns. Django Full-featured web framework. Use with Django REST Framework for API-based microservices. 🌐 Node.js # Framework Description Express.js Minimal and flexible framework for building REST APIs. Fast and widely used. ☕ Java # Framework Description Spring Boot Production-grade microservice framework with robust dependency injection and JPA support. 🧱 C# # Framework Description .NET Core / ASP.NET Core Cross-platform microservice-ready framework by Microsoft. Supports REST APIs out-of-the-box. 🌐 API Testing Tools # Tool Purpose Postman Powerful GUI for testing REST APIs. Bruno Open-source and developer-friendly API testing alternative to Postman. 🐧 Preferred Operating System # OS Version Description Ubuntu 22.04 LTS Long-Term Support, stable and widely used in cloud environments. Ubuntu 24.04 LTS (Upcoming/Recent) Updated LTS version with latest packages. 🗃️ Preferred Databases # Choose your preferred RDBMS per service — all options are supported:\nDatabase Notes PostgreSQL Open-source, feature-rich, and widely used in production. MySQL Lightweight, easy to use, and fast. MSSQL Great for enterprise-grade applications using .NET Core. Each microservice will own its own dedicated database instance.\n🔍 Database Browsing \u0026amp; Inspection Tools # Tool Description DataGrip Universal database IDE by JetBrains (supports all major RDBMS). pgAdmin PostgreSQL’s official web-based admin interface. "}]